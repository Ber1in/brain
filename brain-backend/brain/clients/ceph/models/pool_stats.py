# Copyright (C) 2021 - 2025, Shanghai Yunsilicon Technology Co., Ltd.

# coding: utf-8

"""
    Ceph REST API

    This is the official Ceph REST API

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import Optional
from pydantic import BaseModel
from brain.clients.ceph.models.stat_entry import StatEntry

class PoolStats(BaseModel):
    """
    PoolStats
    """
    stored: Optional[StatEntry] = None
    stored_data: Optional[StatEntry] = None
    stored_omap: Optional[StatEntry] = None
    objects: Optional[StatEntry] = None
    kb_used: Optional[StatEntry] = None
    bytes_used: Optional[StatEntry] = None
    data_bytes_used: Optional[StatEntry] = None
    omap_bytes_used: Optional[StatEntry] = None
    percent_used: Optional[StatEntry] = None
    max_avail: Optional[StatEntry] = None
    quota_objects: Optional[StatEntry] = None
    quota_bytes: Optional[StatEntry] = None
    dirty: Optional[StatEntry] = None
    rd: Optional[StatEntry] = None
    rd_bytes: Optional[StatEntry] = None
    wr: Optional[StatEntry] = None
    wr_bytes: Optional[StatEntry] = None
    compress_bytes_used: Optional[StatEntry] = None
    compress_under_bytes: Optional[StatEntry] = None
    stored_raw: Optional[StatEntry] = None
    avail_raw: Optional[StatEntry] = None
    __properties = ["stored", "stored_data", "stored_omap", "objects", "kb_used", "bytes_used", "data_bytes_used", "omap_bytes_used", "percent_used", "max_avail", "quota_objects", "quota_bytes", "dirty", "rd", "rd_bytes", "wr", "wr_bytes", "compress_bytes_used", "compress_under_bytes", "stored_raw", "avail_raw"]

    class Config:
        """Pydantic configuration"""
        allow_population_by_field_name = True
        validate_assignment = True

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.dict(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> PoolStats:
        """Create an instance of PoolStats from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        """Returns the dictionary representation of the model using alias"""
        _dict = self.dict(by_alias=True,
                          exclude={
                          },
                          exclude_none=True)
        # override the default output from pydantic by calling `to_dict()` of stored
        if self.stored:
            _dict['stored'] = self.stored.to_dict()
        # override the default output from pydantic by calling `to_dict()` of stored_data
        if self.stored_data:
            _dict['stored_data'] = self.stored_data.to_dict()
        # override the default output from pydantic by calling `to_dict()` of stored_omap
        if self.stored_omap:
            _dict['stored_omap'] = self.stored_omap.to_dict()
        # override the default output from pydantic by calling `to_dict()` of objects
        if self.objects:
            _dict['objects'] = self.objects.to_dict()
        # override the default output from pydantic by calling `to_dict()` of kb_used
        if self.kb_used:
            _dict['kb_used'] = self.kb_used.to_dict()
        # override the default output from pydantic by calling `to_dict()` of bytes_used
        if self.bytes_used:
            _dict['bytes_used'] = self.bytes_used.to_dict()
        # override the default output from pydantic by calling `to_dict()` of data_bytes_used
        if self.data_bytes_used:
            _dict['data_bytes_used'] = self.data_bytes_used.to_dict()
        # override the default output from pydantic by calling `to_dict()` of omap_bytes_used
        if self.omap_bytes_used:
            _dict['omap_bytes_used'] = self.omap_bytes_used.to_dict()
        # override the default output from pydantic by calling `to_dict()` of percent_used
        if self.percent_used:
            _dict['percent_used'] = self.percent_used.to_dict()
        # override the default output from pydantic by calling `to_dict()` of max_avail
        if self.max_avail:
            _dict['max_avail'] = self.max_avail.to_dict()
        # override the default output from pydantic by calling `to_dict()` of quota_objects
        if self.quota_objects:
            _dict['quota_objects'] = self.quota_objects.to_dict()
        # override the default output from pydantic by calling `to_dict()` of quota_bytes
        if self.quota_bytes:
            _dict['quota_bytes'] = self.quota_bytes.to_dict()
        # override the default output from pydantic by calling `to_dict()` of dirty
        if self.dirty:
            _dict['dirty'] = self.dirty.to_dict()
        # override the default output from pydantic by calling `to_dict()` of rd
        if self.rd:
            _dict['rd'] = self.rd.to_dict()
        # override the default output from pydantic by calling `to_dict()` of rd_bytes
        if self.rd_bytes:
            _dict['rd_bytes'] = self.rd_bytes.to_dict()
        # override the default output from pydantic by calling `to_dict()` of wr
        if self.wr:
            _dict['wr'] = self.wr.to_dict()
        # override the default output from pydantic by calling `to_dict()` of wr_bytes
        if self.wr_bytes:
            _dict['wr_bytes'] = self.wr_bytes.to_dict()
        # override the default output from pydantic by calling `to_dict()` of compress_bytes_used
        if self.compress_bytes_used:
            _dict['compress_bytes_used'] = self.compress_bytes_used.to_dict()
        # override the default output from pydantic by calling `to_dict()` of compress_under_bytes
        if self.compress_under_bytes:
            _dict['compress_under_bytes'] = self.compress_under_bytes.to_dict()
        # override the default output from pydantic by calling `to_dict()` of stored_raw
        if self.stored_raw:
            _dict['stored_raw'] = self.stored_raw.to_dict()
        # override the default output from pydantic by calling `to_dict()` of avail_raw
        if self.avail_raw:
            _dict['avail_raw'] = self.avail_raw.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: dict) -> PoolStats:
        """Create an instance of PoolStats from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return PoolStats.parse_obj(obj)

        _obj = PoolStats.parse_obj({
            "stored": StatEntry.from_dict(obj.get("stored")) if obj.get("stored") is not None else None,
            "stored_data": StatEntry.from_dict(obj.get("stored_data")) if obj.get("stored_data") is not None else None,
            "stored_omap": StatEntry.from_dict(obj.get("stored_omap")) if obj.get("stored_omap") is not None else None,
            "objects": StatEntry.from_dict(obj.get("objects")) if obj.get("objects") is not None else None,
            "kb_used": StatEntry.from_dict(obj.get("kb_used")) if obj.get("kb_used") is not None else None,
            "bytes_used": StatEntry.from_dict(obj.get("bytes_used")) if obj.get("bytes_used") is not None else None,
            "data_bytes_used": StatEntry.from_dict(obj.get("data_bytes_used")) if obj.get("data_bytes_used") is not None else None,
            "omap_bytes_used": StatEntry.from_dict(obj.get("omap_bytes_used")) if obj.get("omap_bytes_used") is not None else None,
            "percent_used": StatEntry.from_dict(obj.get("percent_used")) if obj.get("percent_used") is not None else None,
            "max_avail": StatEntry.from_dict(obj.get("max_avail")) if obj.get("max_avail") is not None else None,
            "quota_objects": StatEntry.from_dict(obj.get("quota_objects")) if obj.get("quota_objects") is not None else None,
            "quota_bytes": StatEntry.from_dict(obj.get("quota_bytes")) if obj.get("quota_bytes") is not None else None,
            "dirty": StatEntry.from_dict(obj.get("dirty")) if obj.get("dirty") is not None else None,
            "rd": StatEntry.from_dict(obj.get("rd")) if obj.get("rd") is not None else None,
            "rd_bytes": StatEntry.from_dict(obj.get("rd_bytes")) if obj.get("rd_bytes") is not None else None,
            "wr": StatEntry.from_dict(obj.get("wr")) if obj.get("wr") is not None else None,
            "wr_bytes": StatEntry.from_dict(obj.get("wr_bytes")) if obj.get("wr_bytes") is not None else None,
            "compress_bytes_used": StatEntry.from_dict(obj.get("compress_bytes_used")) if obj.get("compress_bytes_used") is not None else None,
            "compress_under_bytes": StatEntry.from_dict(obj.get("compress_under_bytes")) if obj.get("compress_under_bytes") is not None else None,
            "stored_raw": StatEntry.from_dict(obj.get("stored_raw")) if obj.get("stored_raw") is not None else None,
            "avail_raw": StatEntry.from_dict(obj.get("avail_raw")) if obj.get("avail_raw") is not None else None
        })
        return _obj


